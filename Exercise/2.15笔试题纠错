一.作业归还分区，要调整空闲区表，把空闲区表调整成空闲区长度递减的次序排列登记。可变分区分配方式下，当收回主存时，应检查是否有与归还区相邻的空闲区，若有，则应合并成一个空闲区.
   相邻可能有上邻空闲区、下邻空闲区、既上邻又下邻空闲区、既无上邻又无下邻空闲区四种情况：
      1.有上邻空闲区，但无下邻空闲区.只修改上邻空闲区长度（为收回的空闲区长度与原上邻区长度之和），空闲区数不变
      2.无下邻空闲区，但有下邻空闲区.改记录这个下邻空闲区记录的地址为收回空闲区的地址，长度为下邻空闲区的长度和收回空闲区的长度，空闲区数不变
      3.有上邻空闲区，也有下邻空闲区.改记录上邻区记录的长度（为上邻区长度、下邻区长度和收回区长度之和），再把下邻区记录的标志位改为空，即空闲区数-1
      4.无上邻空闲区，也无下邻空闲区.那么找一个标志位为空的记录，记下该回收区的起始地址和长度，且改写相应的标志位为未分配，表明该登记栏中指示了一个空闲区。 空闲区数+1
      
二.任何一个算法不同情况下可能有多种解法，一般我们以时间复杂度为评判的话，就会用牺牲空间换时间。这个算法最明显的有两种解法，
1.每次进来一个变量n，就遍历前面n个数，然后求和，再取平均，这样的话时间复杂度为O（n），空间为O(1)；
2.以空间换时间：从前往后没计算一次保留一次求和值到一个辅助空间，这样计算下一个的时候直接取得前一个和值加上当前数，再取平均得到当前平均，这样的话时间复杂度为O(1),空间为O(n)


3.交换机为独占带宽，即每个端口数据通过率为为最大100Mb/s。注意单位是Mb。因此最短时间为：
  1GB/(100Mb/s)=1024MB/(12.5MB/s)=81.92s。
  
4.当有一个TCP数据段不足MSS，比如要发送700Byte数据，MSS为1460Byte的情况。nagle算法会延迟这个数据段的发送，等待，直到有足够的数据填充成一个完整数据段。
  也许有人会问，这有什么影响呢？没有太大的影响，总体上来说，这种措施能节省不必要的资源消耗。但是要发送的总体数据很小时，这种措施就是拖后腿了。
  比如，用户请求一个网页，大约十几KB的数据，TCP先发送了八九个数据包，剩下几百字节一直不发送，要等到另一个RTT才发送，这时候前面发送数据的ACK已经返回了。
  这样的用户体验是很不好的。 所以，现在很多服务器都选择主动关闭nagle算法，因为带宽够大，资源消耗不是问题，速度反而是个大问题。
  从上述描述中，禁用 nagle，实质就是不在延迟 TCP_NODELAY
  
5.进程问题
  虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件。
  1 ）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
  2 ）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
  3 ）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
  4 ）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
  因此为了避免发生死锁，则不能生成此资源的环形链，则4个进程是极限了
  
6.关于红黑树和AVL树，来自网络：
1 好处及用途
   红黑树 并不追求“完全平衡 ”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。
红黑树能够以 O(log2  n)  的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。
当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。
当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。
在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。
典型的用途是实现关联数组
 
 
2  AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)。
增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis
一棵AVL树满足以下的条件: 
1>它的左子树和右子树都是AVL树 
2>左子树和右子树的高度差不能超过1 
从条件1可能看出是个递归定义,如GNU一样. 

性质: 
1>一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1) 
2>一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)). 
3>一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)). 

从1这点来看 红黑树是牺牲了严格的高度平衡的优越条件 为 代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。
当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.


7.select和epoll这两个机制都是多路I/O机制的解决方案，select为POSIX标准中的，而epoll为Linux所特有的。
epoll的最大好处是不会随着FD的数目增长而降低效率，在select中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll是维护一个队列，直接看队列是不是空就可以了。
nginx就是使用epoll来实现I/O复用支持高并发，目前在高并 发的场景下，nginx越来越收到欢迎。
select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制
epoll:
(1)IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数;
(2)支持电平触发和边沿触发（只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发）两种方式，
理论上边缘触发的性能要更高一些，但是代码实现相当复杂。
(3)有着良好的就绪事件通知机制
select:
(1)单个进程可监视的fd数量受到了限制，在32位机器上，他所能管理的fd数量最大为1024;
(2)对socket进行扫描时是线性扫描，当socket文件描述符数量变多时，大量的时间是被白白浪费掉的
  
  
